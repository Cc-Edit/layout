OCTYPE html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <title>css layout</title>
    <link rel="stylesheet" type="text/css" href="./css/reset.css">
    <link rel="stylesheet" type="text/css" href="./css/style.css">
</head>
<body>
<h1>css布局学习</h1>
<h3>一、基础</h3>	

<h4>1.高度100，宽度自适应</h4>			
<div class="autoWidth"></div>	

<h4>2.高度100，宽度200，实现水平居中</h4>			
<div class="center-x-1">方法一：margin:auto;</div>	

<div class="center-x-2">
    <div class="center-x-2-child">
        方法二：text-align 
    </div>
</div>  

<div class="center-x-3">
    <div class="center-x-3-child">
        方法三：position 
    </div>
</div>  

<h4>3.高度100，宽度自动，实现水平居中</h4>   
<div class="center-x-4">
    <span class="center-x-4-child">
    撑开宽度撑开宽度撑开宽度撑开宽度撑开宽度撑开宽度
    </span>
</div>   

<h4>4.行内元素实现垂直居中</h4>   
<div class="center-y-1">
    <span class="center-y-1-child">撑开内容撑开内容撑开内容撑开内容</span>
</div>  

<h4>5.定高块级元素实现垂直居中</h4>   
<div class="center-y-2">
    <div class="center-y-2-child">方式一：margin: auto;</div>
</div>  

<div class="center-y-3">
    <div class="center-y-3-child">方式二：position;</div>
</div>

<h4>6.边距合并现象</h4>   
<div class="margin-style">
     <div class="margin-style-child">margin: 25px;</div>
     <div class="margin-style-child">margin: 25px;</div>
     <p>两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>    
</div>  

<h4>7.清除浮动</h4>   
<div class="clear-float">
子元素有高度，但是因为float属性，导致父元素没有被撑开。
     <div class="float-l">float:left;</div>
     <div class="float-r">float:right;</div>    
</div>  

<div class="clear-float1">
方式一，给父元素指定高
      <div class="float-l">float:left;</div>
     <div class="float-r">float:right;</div>    
</div>  

<div >
方式二，新加子元素，设置clear:both;
      <div class="float-l">float:left;</div>
     <div class="float-r">float:right;</div> 
     <div style="clear: both;"></div>   
</div>  

<div class="clear-float2">
方式三，设置父元素overflow:hidden;使其覆盖整个内容区
      <div class="float-l">float:left;</div>
     <div class="float-r">float:right;</div> 
</div>  

<div class="clear-float3">
方式四，使用伪类方式清除浮动
      <div class="float-l">float:left;</div>
     <div class="float-r">float:right;</div> 
</div>   

<h3>二、等高布局</h3>

<h4>1.通过背景图方式来做到模拟等高</h4>

<h4>2.通过容器的方式实现等高布局</h4>
<div class="autoh1">
  <div class="autoh2">
    <div class="autoh3">
      <div class="autoh-l">左边</div>
      <div class="autoh-c">中间儿</div>
      <div class="autoh-r">右边</div>
    </div>
  </div>
</div>
<p>
  注释：利用父元素会被子元素内最高的一个撑起来这个特点来实现等高布局
  有多少列就要有多少包含块。设置浮动定位，来将包含块显示对应比例
  然后将子元素右移等比例长度来实现。
  border是为了识别元素的实际高度，缺点是dom结构比较复杂混乱。
</p>

<h4>3.利用border实现的等高布局</h4>
<div class="autoh4">
  <div class="autoh4-l">左边</div>
  <div class="autoh4-c">中间儿</div>
  <div class="autoh4-r">右边</div>
</div>
<p>这种方式比较简单，但是问题也比较明显，就是这种方式最多只能有三列，应因为只有两个border可用</p>

<h4>4.利用正负margin实现等高布局</h4>
<div class="autoh5">
  <div class="autoh5-l">左边</div>
  <div class="autoh5-c">中间儿</div>
  <div class="autoh5-r">右边</div>
</div>
<p>这种方式的原理是使用正的padding值，负的margin值来将列无限撑开，然后设置父元素的overflow：hidden来切割多余部分。他可以用来做多列布局，但是有一个缺点就是他无法显示底边</p>

<h4>5.利用正负margin实现等高布局的基础上增加border</h4>
<div class="autoh5" style="margin-bottom:20px;">
  <div class="autoh5-l">左边</div>
  <div class="autoh5-c">中间儿</div>
  <div class="autoh5-r">右边</div>
  <div class="autoh-border"></div>
</div>

<h4>6.利用定位实现等高布局</h4>
<div class="autoh6" style="margin-bottom:20px;">
  <div class="autoh6-l">左边</div>
  <div class="autoh6-r">右边</div>
</div>
<p>这种方式简单高效，兼容性好，缺点是依旧使用了border的方式进行布局多列的效果不佳</p>

<h4>7.使用table布局来实现等高布局</h4>
<div class="autoh7">
  <div class="autoh-table-row">
    <div class="auto-table-l">左边的</div>
    <div class="auto-table-c">中间的</div>
    <div class="auto-table-r">右边的</div>
  </div>
</div>
<p>同样比较简单的一种方式，但是在IE6，7下无法正常显示</p>

<h3>三、两列布局</h3>
<h4>1.固定宽度，两列居中布局</h4>
<div class="wrapper">
    <h5>例子一：float模式.        父容器固定宽度800居中，模拟显示区</h5>
    <div class="sidebar">
    左侧固定宽度列 200   
    </div>
    <div class="content">
        右侧固定宽度列600
    </div>
</div>

<div class="wrapper">
  <h5>例子二：   margin模式，父容器固定宽度800居中，模拟显示区</h5>
  <div class="content4">
           右侧固定宽度列600
  </div>
  <div class="sidebar4">
        左侧固定宽度列 200   
  </div>
</div>

<h4>2.左列固定宽度，右列自适应，两列布局</h4>
<div class="wrapper1">
    <h5>例子一：父容器宽度随机，左侧固定右侧自适应</h5>
    <div class="sidebar1">
      左侧固定宽度列 200   
    </div>
    <div class="content-wap">
        <div class="content1">
            右侧自适应
        </div>
    </div>
    <p>
        解释下我的理解：content-wap是用来包含右侧自适应模块的，他重要的属性就是float和width：100%；<br>
        比较难理解的是sidebar1的margin-right属性。<br>
        页面渲染的顺序是先渲染sidebar，再渲染content，就会导致content换行，所以指定sidebar的margin-right为自身的宽度，把对应位置的空间让出来，<br>
        理解一下下面的情况，如果把sidebar和content位置换一下<br>
        先渲染content，再渲染sidebar应该怎么写？<br>
    </p>
</div>

<div class="wrapper1">
    <h5>例子二：父容器宽度固定，左侧固定右侧自适应</h5>
    <div class="content-wap">
        <div class="content1">
            右侧自适应
        </div>
    </div>
    <div class="sidebar2">
        左侧固定宽度列 200   
    </div>
    <p>
      解释：由于这次想渲染的content，就会导致slider掉下去<br>
      所以我们需要将slider的左侧的空间清空，让他回到上一行的位置<br>
      也就是我们要设置slider的margi-left为0 - content宽度,是一个变化的值<br>
      所以只在固定布局时使用后置的方式，其他情况还是采取第一种方式
    </p>
</div>

<div class="wrapper1">
    <h5>例子三：父容器宽度固定，左侧固定右侧自适应直接使用margin</h5>
    <div class="sidebar7">
        左侧固定宽度列 200   
    </div>

    <div class="content7">
        右侧自适应
    </div>
  
    <p>
     此方法比起-margin来简单的多。
    </p>
</div>

<h4>3.左列自适应，右列固定宽度，两列布局</h4>
  <div class="wrapper1">
    <h5>父容器宽度固定，左侧自适应右侧固定</h5>
    <div class="content-wap1">
        <div class="content5">  左侧自适应 </div>
    </div>
    <div class="slider5">
            右侧固定宽度
    </div>
  </div>
  <div class="wrapper1">
    <h5>交换content和slider位置</h5>
    <div class="slider6">
      右侧固定宽度
    </div>
    <div class="content-wap1">
      <div class="content5">  左侧自适应 </div>
    </div>
  </div>

<h3>四.各种测试哦~~</h3>
<h4>1.  左定宽度右自适应宽度并且等高布局</h4>
<div class="test">
  <div class="test-l">
  <p style="width: 300px;">撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开撑开</p>
  </div>
  <div class="test-r">right</div>
</div>
<h3>五.三列布局</h3>
<h4>1.固定宽度三列布局</h4>
<div class="three">
  <div class="three-1">左边儿</div>
  <div class="three-2">中间儿</div>
  <div class="three-3">右边儿</div>
</div>
<h4>2.两边固定，中间自适应(float)</h4>
<div class="threea">
  <div class="threea-1">左边儿</div>
  <div class="threea-3">右边儿</div>
  <div class="threea-2">中间儿</div>
</div>
<h4>3.两边固定，中间自适应(margin)</h4>
<div class="three-wa-c">
  <div>中间儿</div>
</div>  
<div class="three-wa-l">
  <div>左边儿</div>
</div>  
<div class="three-wa-r">
  <div>右边儿</div>  
</div>  
<h4>4.两边固定，中间自适应(position)</h4>
<div class="threeb">
    <div class="threeb-1">左边儿</div>
    <div class="threeb-2">中间儿</div>
    <div class="threeb-3">右边儿</div>
</div>
<h4>5.中间固定，两边自适应(margin)</h4>
<div class="threec-wa">
    <div class="threec-l">
      <div>左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿左边儿</div>
    </div>  

    <div class="threec-c">
      <div>中间儿中间儿中间儿中间儿中间儿中间儿中间儿中间儿中间儿中间儿中间儿中间儿</div>
    </div>  

    <div class="threec-r">
      <div>右边儿右边儿右边儿右边儿右边儿右边儿右边儿右边儿右边儿右边儿右边儿右边儿右边儿右边儿</div>
    </div>  
</div>
<h4>6.中间固定，两边自适应（Flex）</h4>
<div class="threed">
  <div class='threed-l'>左边儿</div>
  <div class='threed-c'>中间儿</div>
  <div class='threed-r'>右边儿</div>
</div>
<p>flex布局比较简单，但是会有兼容问题。</p>
</body>
</html>

























































































































